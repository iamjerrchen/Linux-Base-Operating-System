BUGLOG

Checkpoint 1

	Fixing send_eoi - Before I fully understood what was the purpose of send_eoi, I simply used the code from osdev. After understanding why rtc wasn't responding to any interrupts after the first one, I added a eoi signal to the slave port in the master. I realized send_eoi was necessary to tell the respective PIC was done with an interrupt. Since rtc is on the slave IRQ, send_eoi needed to send eoi to both the IRQ 8 (rtc) and IRQ 2 (slave) to say that the slave is done with the interrupt.

	Problem with RTC Interrupt handler. When applying the assembly wrapping to the interrupt handler, I would get random page faults. I started off using pushal and popal. This caused a problem so I started pushing manually and popping manually and accounting for the ordering of the stack. This caused the same problem, but the problem escalated to getting a different exceptions at random. Aside from the page fault, I received a general protection exception. These two alternated. One of the TAs that was helping me debug the error informed me that using function pointers still create a stack, so I needed to include the leave right before iret. This didn't fix the issue, but it was going to be a problem I needed to fix eventually, so I included the leave. The TA and I used gdb to find the exact instruction causing the problem, and the exceptions would occasionally occur and not occur even when the code doesn't get changed. We stepped through and it would execute the handler properly, but then the whole kernel would restart. Eventually the TA suggested to remove pushing and popping ebp and esp. This somehow fixed the issue. The interrupts would start occurring normally without exceptions. After figuring out push and pop ebp was causing problems, We tried pushal, push ebp separately and pop ebp, popal and it worked again. In addition to this test, we also tried the wrapping without ebp and it worked again. I believe the problem when I first tried pushal and popal was because I didn't have the leave command before iret. The problem after with the manual push and pop is because pushing ebp could screw up with the leave and iret commands.
	
	keyboard interrupt handler - sending the IRQ port to send_eoi instead of the IRQ number. This was a mistake made when the user thought send_eoi receieved a port instead of the IRQ number.

Checkpoint 2

	Page Faults in regards to putc - video memory and screen y and screen x needed to be accounted for, this occurred before we learned to reset the cursor to (0,0). I did a double newline and this caused a problem when the second new line was exactly the very last row. Originally the putc function in the '\n' if statement didn't have a condition check whether screen y was greater than 25. First encounter was using printf("\n\nfilename: %s", file_name); After printing out the file, the hello file crashed. This was fixed when we changed putc to properly use screen_x and screen_y.

	A functionality bug that was encountered in the filesystem occurred in the read_data function. The filesystem has pointers for boot block, dentries, inode, and data block. When I was accessing inode and data block. I made the mistake of using the '->' symbol. Since we had an array, using '->' on the pointer to the array of structures caused my code to only access the very first struct every single time no matter what inode or data block I was trying to use. What I should have done was (inode_ptr[index]).struct_member
	
	when testing the read_data function, I was trying to read the data for a specific file but the stuff being printed out was all gibberish. It was nothing like the example posted on Piazza. After some debugging and using gdb, I realized that I created a double pointer buffer and passed it into read_data. It wasn't obvious because it was in this form
		uint8_t* buffer[500];
	I passed in buffer, and I thought I was passing in the pointer of the buffer but I was passing in the pointer to the pointer of the array. read_data accessed the buffer as it should be but accessing it like this (buf[]) of a double pointer will cause unexpected behavior. I removed the extra pointer and the test for reading a file finally worked. I then decided I need a break because that was after 8 hours of working, so I called it a night.
	
Checkpoint 3

	Huge compiler error from #include order. 
	There's three structures that are used between the fd_table files and syscall files: op_data_t, fd_t, and pcb. pcb uses the structure fd_t from the fd_table files, and fd_table needs the op_data_t structure. The problem occurred when the syscall header fille is #included before the fd_table header file. This makes the structure fd_t unavailable until after the pcb is created so it will treat that structure as non-existent. This means that ordering the #includes very important. Originally I tried moving all 3 structures into the syscall.h file. This fixed the nonexistent structure error, but it started affecting all the drivers because they use the op_data_t structure in the function pointer type. In the end I learned from a TA that #including files shouldn't always be done in the .h file. If the source code's functions needs to be used in another source file, the #include should be done in the .c file, not in the .h file.
	To fix the problem, we went to the fd_table.h and moved #include "terminal.h" and #include "keyboard.h" to the fd_table.c file. This makes the functions in those files available to the fd_table, but doesn't create conflict when ordering the structures because no one should #include the .c file. Think of trees and parents. The .c files are end nodes. and .h files are internal nodes. Depending on the ordering, some header files are parents of other .h files. Draw it out.
	
	Exception In the Halt function, Page Fault. Spent several hours the Saturday before the checkpoint. We moved some code up. We accessed the wrong parent child stack when returning to a parent process.
	In the pcb you store the parents esp and ebp values. What happens was when you halt and returning from a child process, you return to the parent pcb esp and ebp, which is two levels ahead. Instead of one level ahead.
	
	Tried running pingpong but it was get stuck in rtc_read because the rtc_handler was never interrupting. Something was locking without restoring so the fix was to sti() at the start of rtc_read to allow interrupts. Then restore the flags back to how it is in case blocking interrupts was necessary before entering the function. This same thing occurred in keyboard. Found the cli without restore, context switch was blocking interrupts and it never unlocked. Nevermind we ended up changing the interrupts for rtc and keyboard trap gates.
	
	Upon entering the shell, the screen printed a bunch of ece391OS> onto the screen. To fix this problem, we added a while loop into keyboard_read to wait for input from the user.
	
	In halt, we were having an issue where our extended status wasn't retaining the correct value. extended status was a local variable initialized at the beginning. It's a 32 bit version of the status parameter. We didn't understand why extended status kept changing when we knew it was supposed to be 256. I used gdb and found that extended status changed from 256 to 0. I used breaks to figure out where it changes. I found that it changes when ebp is changed. This makes sense because local variables are offset from ebp. So if extended_status is offset 1 from the ebp. Moving ebp meant that extended status also changes. So to fix this problem, The extended status variable was changed from a local to a static global variable. This fixes the problem because the location of the variable isn't based on a register and it's consistent in memory. EAX was also modified right before the jump to prevent local code from changing.
	
	Encountered a problem when entering an invalid name. The shell would page fault. The problem was caused from setting up the pages then checking whether the command name was valid. What we should have done was parse then check whether the name was valid. Then set up pages if valid.
	
	Do not read from TSS, we were passing values from parent to child from it. This is a hardware restriction.
	
Checkpoint 4

	I was cleaning up 3.3 so that we have a jump table, and when I was testing to make sure I didn't break anything I typed rtc and it would so no such command, but if I run a program, then run rtc or '.' it would run the most recent program. There was also a problem with a boot loop on certain occasions when running an ls after rtc and/or '.'. I fixed the rtc and '.' running previous program bug by adding a file_type check in execute. return -1 if it's not a file_type of 2. After a file type check it will do a deeper search to make sure it's an executable and not a standard .txt file.
	
	We need to keep an eye out for the boot loop. I believe the previous fix for file type check also fixed this problem. Tested on previous version. More detail to reproduce the problem. Ran ls, ran '.' several times or rtc. Run ls and it will say no command instead of running the program. ls will continue to not work. Then I ran exit and it loops to the boot screen. Problem seems to be gone with the file type check.
	
	I playing around with reading the whole file in the filesystem, and I realized only part of the files were printing out. I spent a couple ours trying to debug and finding the source whether my condition in the while loop was bad (while((retval = file_readâ€¦) > 0), so I decided to do this manually. Read without the file operations. It printed the whole file. I thought the problem was my file_read, but it looked fine. I commented that method out, but it didn't fix the problem. I decided to keep the file_read function call, and remove the terminal_write function call, instead I looped through the whole buffer manually. This fixed the problem. So I realized the problem is in terminal_write. I checked it. Turns out that someone put in a condition that limits the amount of characters outputted to 128, the size of the user terminal buffer. biggest waste of time
	
	Two bugs. Starting off, there was  a problem with grep. Although getargs works with cat and everything else, it didn't work with grep. We poked around and stepped through gdb. Printed out the argument buffer and kept wondering why there are so many spaces in the buffer even thought I filled everything after 'i' (which is the counter of where I left off when transferring chars to the user buffer) with '\0' chars. grep would run without any exceptions or error messages, but at the same time it wouldn't print anything out no matter the argument. We realized that the grep program was never entering the if statement to print out the file name, and we realized that it was including all the spaces at the end when it's looking for the string. This means that if the user inputs 'a', the buffer will have trailing spaces, and it will include that in the search. The reason this occurred is because our condition is that 'i' needs to be less than nbytes and less than the size of a terminal buffer, so since nbytes is larger it will fill the rest of the buffer with spaces since the keyboard buffer has random stuff at the end from a previous input. To fix this problem, we decided to parse backwards and replaced all the spaces with '\0' characters.
	
	Another problem. Hello wasn't going to new line. Originally it was working fine, but when we added the parsing of arguments to another function it gave problems. To fix it. I simply added a new line character at the end of the buffer whenever the command isn't exit.
	
	After inputting so many things, the buffer than shell uses gets filled with junk, so when calling get args after a while it will have random stuff in it and it prevented grep from getting the correct argument. Based on our implementation, since we go backwards and fill in all the end of line characters, it stopped at a random value that isn't supposed to be in there. This caused grep to stop working. To fix this problem I cleaned the given buffer up to nbytes every time to have a safe working environment.

Checkpoint 5

	A lot of the initial problems occured because a specific variable wasn't turned into an array of MAX_TERMINAL. For example, in terminal one, the user enters characters. The user switches, and entered characters, the buffer didn't print out correctly, the reason was that the start location in the second terminal started in the middle of the keyboard. This was because the terminals were sharing the same buffer location variable. To fix it, we just turned it into an array of 3. Each terminal will it's own counter for current buffer location.

	Also, I checked to see what was suppose to happen if there are characters in the keyboard buffer, and the user presses ctrl+l, the screen is suppose to print the buffer back out, according to the given devel. So in the hotkey sequence if statement, I added a for loop to print out everything in the current buffer.

	Video wasn't copying right because we copied video memory to a virtual address that was mapped to the video memory. Copied memory from virtual address mapped to the backup to the video memory. Then we updated the virtual address mapping and this causes a problem since one of them is pointing to video, so doing video copying to video doesn't help. We reorder the 4 lines. we map the one changing to backup. copied from video to the backup, copied other backup to video, and updated the new current terminal.

	In terminal switch, running program in a program switching to another terminal, and returning didn't resume the program. We removed the static local esp and ebp array into the pcb structure and used that in the terminal switch, and now the program resumes.

